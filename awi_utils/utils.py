#	Lupinia Studios
#	By Natasha L.
#	www.lupinia.net | github.com/lupinia
#	
#	=================
#	General utility functions/objects
#	=================

import hashlib
import platform
import random
import string

from django.conf import settings
from django.contrib.sites.models import Site
from django.core.mail import mail_admins, send_mail
from django.utils.html import linebreaks, strip_tags

#	Notification generator
def notify(subject, msg, recipients=None):
	admin_message = {}
	message = {}
	admin_message_status = False
	message_status = False
	
	cur_site_check = Site.objects.filter(pk=settings.SITE_ID)
	if cur_site_check.exists():
		cur_site = cur_site_check.first()
		cur_site_url = cur_site.domain
	else:
		cur_site_url = platform.node()
	msg_text = """%s 

=============
Message generated by %s.""" % (msg, cur_site_url)
	
	admin_message['message'] = msg_text
	admin_message['subject'] = subject
	
	if recipients:
		message['subject'] = '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject)
		message['message'] = msg_text
		message['recipient_list'] = recipients
		message['from_email'] = settings.DEFAULT_FROM_EMAIL
		message_status = send_mail(**message)
		
		admin_message['subject'] = '%s (Admin CC)' % subject
	else:
		message_status = True
	
	admin_message_status = mail_admins(**admin_message)
	
	if admin_message_status and message_status:
		return True
	else:
		return False


#	Convert text that may or may not contain HTML formatting to proper HTML paragraphs/line breaks.
def format_html(input_string):
	if not input_string:
		return input_string
	if "<p>" in input_string or "<br />" in input_string:
		return input_string
	else:
		return linebreaks(input_string)


#	Shorten the input_string to the specified length.
def truncate(input_string, length=255):
	if not input_string or not length:
		# No input, so do nothing.
		return None
	
	if len(input_string) <= length:
		# Already the right length
		return input_string
	else:
		# Trim input_string to length, then split off any interrupted words, then add an ellipsis.
		return input_string[:length].rsplit(' ',1)[0]+'...'


#	Generate a short summary for any longer strings.
#	This was a model method originally, but putting it here is less repetitive.
#	Plus, this can be more powerful and useful than what I could justify with model methods.
#	Parameters:
#		length:  Target maximum character length of summary.  Default: 255 (same as a CharField)
#		body:  The primary body text for the model.  Usually a TextField with unlimited length.
#		summary:  An existing short-summary CharField (<= 255 characters).  If given, this is used in place of body unless length parameter > 255.
#		fallback:  What to return if body and summary are both empty.  Example use-case:  When body and summary are both optional on a model, but it's vital to get a summary of some sort anyway, return the title.
#		strip:  If False, strip_tags will not be run.  Not recommended, but could be necessary in some cases.
#		prefer_long:  If True, summary will only be used if its len >= length.  Useful when you know you want a string of a certain length but your summary value might be far shorter than that, despite the summary value being non-empty.
def summarize(body=None, length=255, summary=None, fallback=None, strip=True, prefer_long=False):
	if not body and not summary:
		# Nothing to do!
		return fallback
	
	result = None
	
	# If there's a summary, we'll try that first.
	# if prefer_long == False, summary is the priority
	# if prefer_long == True and len(summary) >= length, summary is still the priority
	if summary and (not prefer_long or (prefer_long and len(summary) >= length)):
		summary = strip_tags(summary)
		result = truncate(summary, length)
	
	# If we don't have anything at this point, for whatever reason, we'll try the body text.
	if result is None and body:
		body = strip_tags(body)
		result = truncate(body, length)
	
	if not result:
		# After all that, we still don't have anything.
		return fallback
	else:
		# We did the thing!  Whether it was the right thing is up to you, but this part worked correctly!
		return result


#	More compact version of using hashlib to generate various types of hashes from strings
def hash_md5(source):
	hash = hashlib.md5(source)
	return hash.hexdigest()

def hash_sha1(source):
	hash = hashlib.sha1(source)
	return hash.hexdigest()

def hash_sha256(source):
	hash = hashlib.sha256(source)
	return hash.hexdigest()

def hash_sha512(source):
	hash = hashlib.sha512(source)
	return hash.hexdigest()


#	Generate a random integer sequence of a specific length.
#		duplicates:  Boolean.  If True, sequential duplicates are allowed.
#		first_zero:  Boolean.  If True, first digit in sequence can be a zero.
#		exclude_zero:  Boolean.  If True, no zeros will be part of the sequence.
def rand_int_list(length=1, duplicates=False, first_zero=False, exclude_zero=False):
	# Handle bad inputs, just in case
	if length < 1:
		return []
	elif length > 1024:
		length = 1024
	
	generator = random.SystemRandom()
	int_list = []
	i = 0
	while i < length:
		if exclude_zero:
			range_start = 1
		elif not first_zero and not i:
			range_start = 1
		else:
			range_start = 0
		int_list.append(generator.randrange(range_start, 10))
		i += 1
		
		# Check for sequential duplicates
		if duplicates == False and i > 1:
			if int_list[i-1] == int_list[i-2]:
				int_list.pop()
				i -= 1
	
	return int_list

#	Generate a random letter sequence of a specific length.
#		duplicates:  Boolean.  If True, sequential duplicates are allowed.
#		mix_case:  Boolean.  If True, both upper and lowercase letters will be included.  Else, only uppercase will be returned.
#		exclude:  List.  Any characters in this list will be removed from the possible selections, case-insensitively.
#		include_digits:  Boolean.  If True, numbers will also be added to the selection pool.
#		first_zero:  Boolean.  If True, first digit in sequence can be a zero.  Only has an effect if include_digits is also true.
def rand_char_list(length=1, duplicates=False, mix_case=False, exclude=[], include_digits=False, first_zero=False):
	# Handle bad inputs, just in case
	if length < 1:
		return []
	elif length > 1024:
		length = 1024
	
	# Set up the initial range
	if mix_case:
		char_range = string.ascii_letters
	else:
		char_range = string.ascii_uppercase
	
	if include_digits:
		char_range += '0123456789'
	
	for ex in exclude:
		char_range = char_range.replace(ex.lower(), '')
		char_range = char_range.replace(ex.upper(), '')
	
	generator = random.SystemRandom()
	char_list = []
	i = 0
	
	while i < length:
		char_list.append(generator.choice(char_range))
		i += 1
		
		# Check for sequential duplicates
		if duplicates == False and i > 1:
			if char_list[i-1].lower() == char_list[i-2].lower():
				char_list.pop()
				i -= 1
		elif not first_zero and i == 1:
			if char_list[0] == '0':
				char_list.pop()
				i -= 1
	
	return char_list

#	Special type of random character generator that generates a license plate number
#	Each character in the sequence string will be replaced individually, 
# 	so the length of the sequence defines the length of the returned string
#	Use the following characters to define a valid sequence:
#		#: Number (0-9)
#		+: Non-Zero Number (1-9)
#		?: Letter (excluding I or O)
#		*: Letter or number (0-9), excluding I or O
#	Any other characters in the sequence will treated as literal and not replaced
#	This includes specific letters and numbers, or spaces and hyphens.
def rand_license_plate(sequence):
	plate_number = []
	if len(sequence) > 128:
		sequence = sequence[:127]
	
	# Let's go through this one letter at a time
	i = 0
	length = len(sequence)
	while i < length:
		char = sequence[i]
		new_char = ''
		literal = False
		
		# Let's look for numbers first
		if char == '#' or char == '+':
			if char == '+':
				no_zero = True
			else:
				no_zero = False
			new_char = str(rand_int_list(1, exclude_zero=no_zero, first_zero=True)[0])
		
		# If it's not a number, maybe it's a letter?
		elif char == '?' or char == '*':
			if char == '*':
				digits = True
			else:
				digits = False
			new_char = rand_char_list(1, exclude=['i', 'o'], include_digits=digits)[0]
		
		# Must be a literal, then
		else:
			new_char = char
			literal = True
		
		# Let's do some clean-up
		if i == 0 or literal:
			# If this is the first character, or it's a literal character, always use it
			plate_number.append(new_char)
			i += 1
		elif new_char != plate_number[i-1]:
			# If this is a random character and not the first one, only use it if it's not a duplicate
			plate_number.append(new_char)
			i += 1
	
	# All done!
	return ''.join(plate_number)


#	Since Django is stupidly picky about what it will accept for model field choices, 
#	I have to write a function that will turn the output of .keys() from a dict into tuple pairs.
def dict_key_choices(source_dict):
	keys = source_dict.keys()
	tuple_list = []
	
	for key in keys:
		tuple_list.append((key, key))
	
	return tuple_list


#	Normally, I'm all for duck typing, but sometimes that's just not good enough.
def is_iterable(test_obj):
	try:
		test_obj_iterator = iter(test_obj)
	except TypeError:
		return False
	else:
		return True

def is_int(test_obj):
	try:
		test_obj_iterator = int(test_obj)
	except ValueError:
		return False
	except TypeError:
		return False
	else:
		return True

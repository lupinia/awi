#	Lupinia Studios
#	By Natasha L.
#	www.lupinia.net | github.com/lupinia
#	
#	=================
#	General utility functions/objects
#	=================

import hashlib
import platform
import random
import string

from django.conf import settings
from django.contrib.sites.models import Site
from django.core.mail import mail_admins, send_mail

#	Notification generator
def notify(subject, msg, recipients=None):
	admin_message = {}
	message = {}
	admin_message_status = False
	message_status = False
	
	cur_site_check = Site.objects.filter(pk=settings.SITE_ID)
	if cur_site_check.exists():
		cur_site = cur_site_check.first()
		cur_site_url = cur_site.domain
	else:
		cur_site_url = platform.node()
	msg_text = """%s 

=============
Message generated by %s.""" % (msg, cur_site_url)
	
	admin_message['message'] = msg_text
	admin_message['subject'] = subject
	
	if recipients:
		message['subject'] = '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject)
		message['message'] = msg_text
		message['recipient_list'] = recipients
		message['from_email'] = settings.DEFAULT_FROM_EMAIL
		message_status = send_mail(**message)
		
		admin_message['subject'] = '%s (Admin CC)' % subject
	else:
		message_status = True
	
	admin_message_status = mail_admins(**admin_message)
	
	if admin_message_status and message_status:
		return True
	else:
		return False




#	More compact version of using hashlib to generate various types of hashes from strings
def hash_md5(source):
	hash = hashlib.md5(source)
	return hash.hexdigest()

def hash_sha1(source):
	hash = hashlib.sha1(source)
	return hash.hexdigest()

def hash_sha256(source):
	hash = hashlib.sha256(source)
	return hash.hexdigest()

def hash_sha512(source):
	hash = hashlib.sha512(source)
	return hash.hexdigest()


#	Generate a random integer sequence of a specific length.
#		duplicates:  Boolean.  If True, sequential duplicates are allowed.
#		first_zero:  Boolean.  If True, first digit in sequence can be a zero.
#		exclude_zero:  Boolean.  If True, no zeros will be part of the sequence.
def rand_int_list(length=1, duplicates=False, first_zero=False, exclude_zero=False):
	# Handle bad inputs, just in case
	if length < 1:
		return []
	elif length > 1024:
		length = 1024
	
	generator = random.SystemRandom()
	int_list = []
	i = 0
	while i < length:
		if exclude_zero:
			range_start = 1
		elif not first_zero and not i:
			range_start = 1
		else:
			range_start = 0
		int_list.append(generator.randrange(range_start, 10))
		i += 1
		
		# Check for sequential duplicates
		if duplicates == False and i > 1:
			if int_list[i-1] == int_list[i-2]:
				int_list.pop()
				i -= 1
	
	return int_list

#	Generate a random letter sequence of a specific length.
#		duplicates:  Boolean.  If True, sequential duplicates are allowed.
#		mix_case:  Boolean.  If True, both upper and lowercase letters will be included.  Else, only uppercase will be returned.
#		exclude:  List.  Any characters in this list will be removed from the possible selections, case-insensitively.
#		include_digits:  Boolean.  If True, numbers will also be added to the selection pool.
#		first_zero:  Boolean.  If True, first digit in sequence can be a zero.  Only has an effect if include_digits is also true.
def rand_char_list(length=1, duplicates=False, mix_case=False, exclude=[], include_digits=False, first_zero=False):
	# Handle bad inputs, just in case
	if length < 1:
		return []
	elif length > 1024:
		length = 1024
	
	# Set up the initial range
	if mix_case:
		char_range = string.ascii_letters
	else:
		char_range = string.ascii_uppercase
	
	if include_digits:
		char_range += '0123456789'
	
	for ex in exclude:
		char_range = char_range.replace(ex.lower(), '')
		char_range = char_range.replace(ex.upper(), '')
	
	generator = random.SystemRandom()
	char_list = []
	i = 0
	
	while i < length:
		char_list.append(generator.choice(char_range))
		i += 1
		
		# Check for sequential duplicates
		if duplicates == False and i > 1:
			if char_list[i-1].lower() == char_list[i-2].lower():
				char_list.pop()
				i -= 1
		elif not first_zero and i == 1:
			if char_list[0] == '0':
				char_list.pop()
				i -= 1
	
	return char_list

#	Special type of random character generator that generates a license plate number
#	Each character in the sequence string will be replaced individually, 
# 	so the length of the sequence defines the length of the returned string
#	Use the following characters to define a valid sequence:
#		#: Number (0-9)
#		+: Non-Zero Number (1-9)
#		?: Letter (excluding I or O)
#		*: Letter or number (0-9), excluding I or O
#	Any other characters in the sequence will treated as literal and not replaced
#	This includes specific letters and numbers, or spaces and hyphens.
def rand_license_plate(sequence):
	plate_number = []
	if len(sequence) > 128:
		sequence = sequence[:127]
	
	# Let's go through this one letter at a time
	i = 0
	length = len(sequence)
	while i < length:
		char = sequence[i]
		new_char = ''
		literal = False
		
		# Let's look for numbers first
		if char == '#' or char == '+':
			if char == '+':
				no_zero = True
			else:
				no_zero = False
			new_char = str(rand_int_list(1, exclude_zero=no_zero, first_zero=True)[0])
		
		# If it's not a number, maybe it's a letter?
		elif char == '?' or char == '*':
			if char == '*':
				digits = True
			else:
				digits = False
			new_char = rand_char_list(1, exclude=['i', 'o'], include_digits=digits)[0]
		
		# Must be a literal, then
		else:
			new_char = char
			literal = True
		
		# Let's do some clean-up
		if i == 0 or literal:
			# If this is the first character, or it's a literal character, always use it
			plate_number.append(new_char)
			i += 1
		elif new_char != plate_number[i-1]:
			# If this is a random character and not the first one, only use it if it's not a duplicate
			plate_number.append(new_char)
			i += 1
	
	# All done!
	return ''.join(plate_number)


#	Since Django is stupidly picky about what it will accept for model field choices, 
#	I have to write a function that will turn the output of .keys() from a dict into tuple pairs.
def dict_key_choices(source_dict):
	keys = source_dict.keys()
	tuple_list = []
	
	for key in keys:
		tuple_list.append((key, key))
	
	return tuple_list


#	Normally, I'm all for duck typing, but sometimes that's just not good enough.
def is_iterable(test_obj):
	try:
		type_test = iter(test_obj)
	except TypeError:
		return False
	else:
		return True

def is_int(test_obj):
	try:
		type_test = int(test_obj)
	except ValueError:
		return False
	except TypeError:
		return False
	else:
		return True

def is_string(test_obj):
	return isinstance(test_obj, basestring) # type: ignore
